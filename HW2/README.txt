Μπριάκος Σπυρίδων 1115201700101 

Αφού τοποθετηθούν τα javacc5.jar και jtb132di.jar αρχεία στον κεντρικό folder HW2/, από τον ίδιο folder:
Compile: make 
Execute: java Main [filename1] [filename2] .. [filenameN]
Clean: make clean

Η εργασία αποτελείται από: 
- minijava-examples/, όπου υπάρχουν test cases που χρησιμοποιήθηκαν για να ελέγξω αν όλα λειτουργούν με σωστό τρόπο.
- src/, όπου υπάρχουν όλα τα .java αρχεία που δημιουργήθηκαν για την εν λόγω εργασία
- javacc5.jar
- jtb132di.jar
- Main.java
- makefile
- minijava.jj
- README.txt

Τα αρχεία που δημιουργήθηκαν για την εν λόγω εργασία είναι το Main.java και όλα τα .java αρχεία που εμπεριέχονται στον φάκελο src/. Πιο αναλυτικά:
- Main.java, δημιουργεί τους τρεις visitors και εκτυπώνει για κάθε ξεχωριστό αρχείο που έδωσε ο χρήστης τα offsets (αν δεν υπάρχει κάποιο σημασιολογικό λάθος).
- Symbol_Table.java, εμπεριέχει ουσιαστικά την δομή hash_table, μέσα στην οποία για κάθε κλάση αποθηκεύεται το pair <name,object>.
- Class.java, υλοποιήθηκε για την εκάστοτε κλάση κρατώντας σημαντικές πληροφορίες για την ίδια, αλλά ταυτόχρονα υπάρχουν πολλές βασικές συναρτήσεις που χρησιμοποιούνται από τους δύο τελευταίους visitors.
- Method.java, υλοποιήθηκε για την εκάστοτε μέθοδο κρατώντας σημαντικές πληροφορίες για την ίδια, χωρίς να έχει πολλές ορισμένες συναρτήσεις.
- Variable.java, υλοποιήθηκε για την εκάστοτε μεταβλητή κρατώντας σημαντικές πληροφορίες για την ίδια, κρατά μονάχα τρεις μεταβλητές (type,name,offset).
- First_Visitor.java, στόχος του είναι να ελέγξει τους ορισμούς των κλάσεων, συμπεριλαμβανομένης και της Main_Class, την οποία την χειριζόμαστε ξεχωριστά.
- Second_Visitor.java, στόχος του είναι να ελέγξει το σώμα των κλάσεων, αν βέβαια όλα έχουν πάει σωστά στον First_Visitor.
- Third_Visitor.java, στόχος του είναι να ελέγξει τις περισσότερες λεπτομέρειες που δεν ορίστηκαν στους δύο προαναφερθέντες visitors (ο μεγαλύτερος όγκος βρίσκεται εδώ).

Το σκεπτικό με τους τρεις ξεχωριστούς visitors, εξυπηρετεί αρκετά την κατανόηση του πως λειτουργούν οι visitors, διότι έχοντας 'κομματιάσει' τις διεργασίες σε περισσότερους
από έναν Visitor, αντιλαμβανόμαστε πολύ πιο γρήγορα όταν κάνουμε testing-debugging, σε ποιον δημιουργήθηκε το πρόβλημα. Αν π.χ. κρασάρει το αρχείο που δώσαμε στον πρώτο 
Visitor, τότε υπάρχει κάποιο τρανταχτό λάθος στον ορισμό των κλάσεων (όπως η διπλή δήλωση της ίδιας κλάσης). Άρα, αντιλαμβανόμαστε πως στον τελευταίο Visitor θα υπάρχουν
τα περισσότερα και πιο 'δύσκολα' errors.

Αξίζει να αναφερθούν τα πιο δύσκολα σημεία της εργασίας, που ήταν αρχικά η MessageSend. Στην οποία δημιούργησα στον ThirdVisitor μια δομή στοίβας από λίστες από strings, πράγμα που έλυσε
το πρόβλημα του να κληθεί ένα MessageSend μέσα σε ένα άλλο MessageSend (i.e this.foo(this.bla() ). Ακόμη μια πολύ χρήσιμη συνάρτηση ήταν η Polymorphism(), η οποία 
βοήθησε αρκετά στο να καταλαβαίνω αν έχουμε πολυμορφισμό ή όχι (όποτε να βγεί Exception Error). Τέλος, επειδή οι οδηγίες που δόθηκαν είναι πως επιτρέπεται σε μεθόδους
μόνον overriding, δημιούργησα μια συνάρτηση HandleOverloading(), για να ελέγχω αν δύο συναρτήσεις έχουν ουσιαστικά ίδιο τύπο επιστροφής, ίδιο όνομα αλλά και ίδια ορίσματα.

Να σημειωθεί πως στο terminal, εκτός από τις αναμενόμενες εκτυπώσεις των offsets, υπάρχουν διαχωρισμένες κάποιες εκτυπώσεις, που με βοήθησαν στην κατανόηση της λειτουργικότητας
της εργασίας, αλλά και στην εύρεση κάποιου λάθους (ενδέχεται να είναι σχολιασμένες). Δεν υπάρχει όμως καμία σύγχυση καθώς κάθε αρχείο του χρήστη αρχείο διαχωρίζεται με ενα κελί, π.χ. 
##########################################################
# File: 'minijava-examples/piazza-examples/Piazza8.java' #
##########################################################